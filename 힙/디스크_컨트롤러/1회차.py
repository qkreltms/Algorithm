#문제(DP 익히면 다시 해볼 것!)
'''
return 평균을 최대한 줄인 순서대(낮은 작업시간을 젤 빨리 처리함)로
하면 시간소요가 어느정도인지

한번에 하나의 작업
요청이 들어온 순대로 단, 정렬 가능
요청 시간이 있음 예를 들어 3ms 시작 작업을 가장 요청시간이 작다는 이유로 
0ms부터 시작 할 수 없음
'''
#풀이
'''
[[1,2], [0,10]] 일 때 큰걸 먼저 시작하는게 이득
[[1,20], [0,10]] 일 때 0,10을 먼저 시작하는게 이득
[[0,2], [0,10]] 일 때 아무거나 실행해도 문제 없음
즉, 앞 작업에 딜레이 될 때가 문제임

[[0,2], [5,10], [6,7]] 일 때 A=> B =>C로  가야됨

작업 시작 시점으로 순서를 잡고
시간이 밀려서 겹쳤을 때 앞 작업으로 부터 시작 + 작업 시간했을 때 짧은것 순으로 

1. min 힙에 작업 시작 순으로 값을 [시작 시간, 작업 시간]으로 넣는다.
2. d[...] = 9999, root 값 d[1]에 넣음, f(a, b, 1)

f(pa, pb, i):
    stack = []
    while True:
        heap이 비어있으면 stack에 하나 넣어주고 break 
        [a,b] = heap.pop()
        if a,b 가 pa,pb 범위에 속한다:
            stack.append([a,b])
        else: break
    past = []
    last = None
    do:
        v = stack.pop()
        b = v[1]
        if d[i] > d[i] + b:
            d[i] = d[i-1] + b
            last = v
        past.append(v)
    while stack
    
    past에서 last값을 제거하고 나머지 값은 heap에 다시 놓는다.
    
    if heap이 비어있다:
        return
    [a, b] = heap.pop()
    f(a, b, i+1)
'''
import heapq


#반례
'''
[[1,2], [0,10]]