#문제
'''
return 주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 1026, 2610, 2106]를 만들 수 있고, 이중 가장 큰 수는 6210를 출력하라
numbers의 길이는 1 이상 100,000 이하입니다.
numbers의 원소는 0 이상 1,000 이하입니다.
정답이 너무 클 수 있으니 문자열로 바꾸어 return 합니다.
'''
#키 포인트
'''
1. 모든 조합을 만들어 비교하되, O(n^2)이 나오지 않게 해야한다 => sort 사용


2. 값이 1의 자리에 가까울 수록 큰 값이 젤 앞에 위치해야 한다. 
예: 9 > 8888
복잡한 로직을 만들어 1의 자리부터 n 자리까지 비교해야되느냐?
아래의 말을 보자
"numbers의 원소는 0 이상 1,000 이하입니다." 
어떤 값을 4자리로 만들어서 비교한다. 단, 그 값을 반복해서 만든다.
9999 (9) >  9898(원래 값: 98)
'''
def solution(numbers):
    return str(int(''.join(sorted(list(map(str, numbers)), key=lambda x: int((x*4)[0:4]), reverse=True))))


print(solution([6, 10, 2]), 6210)
print(solution([3, 30, 34, 5, 9]), 9534330)
print(solution([0,0,0,0]), 0) # 결과 값을 int로 바꿔주고 str로 바꿔준다.
